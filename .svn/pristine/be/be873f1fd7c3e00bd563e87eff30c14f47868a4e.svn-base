import React, { useEffect, useState, useRef } from 'react';
import { useParams, useSearchParams, useNavigate } from 'react-router-dom'; // useSearchParams ì¶”ê°€
import io from 'socket.io-client';
import { BsMic, BsMicMute, BsCameraVideo, BsCameraVideoOff, BsChatDots, BsTelephoneX, BsSend } from "react-icons/bs";
import { IoClose } from "react-icons/io5";
import swal from 'sweetalert2';

// í™˜ê²½ ì„¤ì •
// const DEVELOPMENT_IP = '192.168.143.22';
const DEVELOPMENT_IP = '192.168.43.97';
// â˜… ë°°í¬ ì‹œ ì‹¤ì œ ë„ë©”ì¸ìœ¼ë¡œ ë³€ê²½
// const SIGNALING_SERVER_URL = "https://localhost:3000";
const SIGNALING_SERVER_URL = `https://${DEVELOPMENT_IP}:3000`;
const AWS_PUBLIC_IP = '54.180.87.110';   // AWS Public IP
const TURN_USERNAME = 'turnuser';
const TURN_PASSWORD = 'turnpassword';

// STUN/TURN ì„œë²„ ì„¤ì •
const iceServers = {
    iceServers: [
        // 1. Google STUN Server
        { urls: 'stun:stun.l.google.com:19302' },

        // 3. TURN/UDP (ì¼ë°˜ ì¤‘ê³„) - 3478 í¬íŠ¸
        {
          urls: `turn:${AWS_PUBLIC_IP}:3478`,
          username: TURN_USERNAME,
          credential: TURN_PASSWORD
        },
    ]
};

// JWT í† í° ë””ì½”ë”© í•¨ìˆ˜ (í•œê¸€ ê¹¨ì§ ë°©ì§€ ë¡œì§ í¬í•¨)
const parseJwt = (token) => {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
        return JSON.parse(jsonPayload);
    } catch (e) {
        return null;
    }
};

const VideoMeetingRoom = () => {
    const { roomId } = useParams(); // URL Path: /video/room/{roomId}
    const [searchParams] = useSearchParams(); // URL Query: ?token=...
    const navigate = useNavigate();

    // 1. URLì—ì„œ í† í° ì¶”ì¶œ ë° ë””ì½”ë”©
    const jwtToken = searchParams.get("token");
    const decodedToken = jwtToken ? parseJwt(jwtToken) : null;
    
    // í† í°ì—ì„œ ì´ë¦„ êº¼ë‚´ê¸° (ì—†ìœ¼ë©´ Guest)
    const myName = decodedToken?.memName || "Guest";

    // 2. ìƒíƒœ ê´€ë¦¬
    const [peers, setPeers] = useState([]); // ì ‘ì†ì ëª©ë¡
    const [msgs, setMsgs] = useState([]);   // ì±„íŒ… ë©”ì‹œì§€
    const [inputMsg, setInputMsg] = useState("");
    const [isChatOpen, setIsChatOpen] = useState(false);
    
    // ë¯¸ë””ì–´ ìƒíƒœ
    const [micOn, setMicOn] = useState(true);
    const [camOn, setCamOn] = useState(true);

    // 3. Refs
    const socketRef = useRef();
    const myStreamRef = useRef();
    const myVideoRef = useRef();
    const pcsRef = useRef({}); // N:N PeerConnection ì €ì¥ì†Œ

    // ============================================================
    //  ì´ˆê¸°í™”: í† í° ê²€ì¦ -> ë¯¸ë””ì–´ íšë“ -> ì†Œì¼“ ì—°ê²°
    // ============================================================
    useEffect(() => {
        if (socketRef.current || myStreamRef.current) return;

        const init = async () => {
            // í† í° ìœ íš¨ì„± ì²´í¬
            if (!jwtToken || !decodedToken) {
                /* ë°°í¬ì‹œ ì£¼ì„ í•´ì œ */
                await swal.fire("ì ‘ê·¼ ì˜¤ë¥˜", "ìœ íš¨í•˜ì§€ ì•Šì€ ì…ì¥ê¶Œì…ë‹ˆë‹¤.", "error");
                // Spring Boot ë©”ì¸ í˜ì´ì§€ë¡œ ê°•ì œ ì´ë™ (í¬íŠ¸ í™•ì¸ 8060)
                window.location.href = "http://localhost:8060/tudio/videoChat/list";
                return;       
            }

            try {
                // 1. ì¹´ë©”ë¼/ë§ˆì´í¬ ê°€ì ¸ì˜¤ê¸°
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                myStreamRef.current = stream;
                
                // ë‚´ í™”ë©´ ë³´ì—¬ì£¼ê¸°
                if (myVideoRef.current) {
                    myVideoRef.current.srcObject = stream;
                    myVideoRef.current.muted = true;
                }

                // 2. ì†Œì¼“ ì—°ê²° ì‹œì‘
                connectSocket();

            } catch (err) {
                console.error(err);
                /* swal.fire("ë¯¸ë””ì–´ ì˜¤ë¥˜", "ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.", "warning"); */
                swal.fire({
                    icon: 'warning',
                    title: 'ì¹´ë©”ë¼/ë§ˆì´í¬ ê¶Œí•œ í•„ìš”',
                    html: `ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì¸í•´ ê¶Œí•œì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
                           <b>chrome://flags</b> ì ‘ì† í›„<br>
                           'Insecure origins treated as secure' í•­ëª©ì—<br>
                           í˜„ì¬ ì£¼ì†Œ(http://${DEVELOPMENT_IP}:5173)ë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”.`
                });
            }
        };

        init();

        // Cleanup
        return () => {
            if (socketRef.current) socketRef.current.disconnect();
            if (myStreamRef.current) myStreamRef.current.getTracks().forEach(t => t.stop());
            Object.values(pcsRef.current).forEach(pc => pc.close());
        };
    }, []); // ì˜ì¡´ì„± ë°°ì—´ ë¹„ì›€ (í•œ ë²ˆë§Œ ì‹¤í–‰)

    // ============================================================
    //  ì†Œì¼“ ì—°ê²° ë° ì´ë²¤íŠ¸ í•¸ë“¤ë§
    // ============================================================
    const connectSocket = () => {
        socketRef.current = io.connect(SIGNALING_SERVER_URL, {
            auth: { token: jwtToken }, // â˜… í† í° ì œì¶œ
            rejectUnauthorized: false
        });

        const socket = socketRef.current;

        socket.on("connect", () => {
            console.log("âœ… ì‹œê·¸ë„ë§ ì„œë²„ ì—°ê²°ë¨");
            socket.emit("join_room", { roomId });
        });

        socket.on("connect_error", (err) => {
            console.error("ì†Œì¼“ ì—°ê²° ì‹¤íŒ¨:", err);
        });

        // 1. [N:N] ê¸°ì¡´ ìœ ì € ë°œê²¬ (ë‚´ê°€ Offer ë³´ëƒ„)
        socket.on("all_users", (users) => {
            console.log(`ê¸°ì¡´ ìœ ì € ${users.length}ëª…`);
            users.forEach(user => {
                // createPeerConnection(user.socketId, user.name, true);
                createPeerConnection(user.socketId, user.name || "ìµëª…", true);
            });
        });

        // 2. [N:N] ìƒˆ ìœ ì € ì…ì¥ (Offer ê¸°ë‹¤ë¦¼)
        socket.on("user_joined", (user) => {
            console.log(`ìƒˆ ìœ ì € ì…ì¥: ${user.name}`);
            swal.fire({
                toast: true, position: 'top-end', icon: 'info', 
                title: `${user.name}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.`, showConfirmButton: false, timer: 3000
            });
            createPeerConnection(user.socketId, user.name, false);
        });

        // 3. WebRTC ì‹œê·¸ë„ë§
        socket.on("offer", async ({ from, offer }) => {
            const pc = pcsRef.current[from];
            if (pc) {
                await pc.setRemoteDescription(offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit("answer", { targetId: from, answer });
            }
        });

        socket.on("answer", async ({ from, answer }) => {
            const pc = pcsRef.current[from];
            if (pc) await pc.setRemoteDescription(answer);
        });

        socket.on("ice", async ({ from, candidate }) => {
            console.log(`[WebRTC] ICE ìˆ˜ì‹  <- ${from}`);
            const pc = pcsRef.current[from];
            // if (pc) await pc.addIceCandidate(candidate);
            if (pc) {
                try {
                    // ìƒëŒ€ë°© ì„¤ì •(RemoteDescription)ì´ ëë‚œ í›„ì—ë§Œ Candidate ì¶”ê°€ ê°€ëŠ¥
                    if (pc.remoteDescription) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } else {
                        console.warn("RemoteDescriptionì´ ì—†ì–´ ICE ëŒ€ê¸° ì¤‘...");
                    }
                } catch (e) {
                    console.error("ICE ì¶”ê°€ ì—ëŸ¬", e);
                }
            }
        });

        // 4. ìœ ì € í‡´ì¥ (ì„œë²„ ì´ë²¤íŠ¸ëª…ê³¼ ì¼ì¹˜í•˜ë„ë¡)
        socket.on("user_left", ({ socketId }) => {
            console.log(`ìœ ì € í‡´ì¥: ${socketId}`);
            if (pcsRef.current[socketId]) {
                pcsRef.current[socketId].close();
                delete pcsRef.current[socketId];
            }
            setPeers(prev => prev.filter(p => p.socketId !== socketId));
        });

        // 5. ì±„íŒ… ìˆ˜ì‹ 
        socket.on("chat_message", (msg) => {
            setMsgs(prev => [...prev, msg]);
        });
    };

    // ============================================================
    //  WebRTC í•µì‹¬ ë¡œì§
    // ============================================================
    const createPeerConnection = (socketId, userName, isInitiator) => {
        if (pcsRef.current[socketId]) return;

        const pc = new RTCPeerConnection(iceServers);

        // ë‚´ íŠ¸ë™ ì¶”ê°€
        if (myStreamRef.current) {
            myStreamRef.current.getTracks().forEach(track => pc.addTrack(track, myStreamRef.current));
        }

        // ICE Candidate
        pc.onicecandidate = (e) => {
            if (e.candidate) {
                socketRef.current.emit("ice", { targetId: socketId, candidate: e.candidate });
            }

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    
                    socketRef.current.emit("ice", { targetId: socketId, candidate: e.candidate });
                }
            };
        };

        // ìƒëŒ€ë°© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  ì‹œ í™”ë©´ ì—…ë°ì´íŠ¸
        pc.ontrack = (e) => {
            setPeers(prev => {
                // ì´ë¯¸ ëª©ë¡ì´ ìˆìœ¼ë©´ ë¬´ì‹œ
                if (prev.find(p => p.socketId === socketId)) return prev;
                // ìƒˆ ìœ ì € ì¶”ê°€
                return [...prev, { socketId, name: userName, stream: e.streams[0] }];
            });
        };

        pcsRef.current[socketId] = pc;

        // ë‚´ê°€ ë¨¼ì € ë“¤ì–´ì˜¨ ì‚¬ëŒ(Initiator)ì´ë©´ offer ìƒì„±
        if (isInitiator) {
            pc.onnegotiationneeded = async () => {
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socketRef.current.emit("offer", { targetId: socketId, offer });
                } catch (err) {
                    console.error("Offer ìƒì„± ì‹¤íŒ¨:", err);
                }
            };
        }
    };

    // ============================================================
    //  UI í•¸ë“¤ëŸ¬
    // ============================================================
    const handleEndCall = () => {
        swal.fire({
            title: 'ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
            text: "íšŒì˜ì‹¤ì„ ë‚˜ê°€ë©´ ì—°ê²°ì´ ì¢…ë£Œë©ë‹ˆë‹¤.",
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            confirmButtonText: 'ë‚˜ê°€ê¸°',
            cancelButtonText: 'ì·¨ì†Œ'
        }).then((result) => {
            if (result.isConfirmed) {
                // Spring Boot(8080) ëª©ë¡ í˜ì´ì§€ë¡œ ë³µê·€
                window.location.href = "http://localhost:8060/tudio/videoChat/list"; 
            }
        });
    };

    const sendChat = () => {
        if (!inputMsg.trim()) return;
        socketRef.current.emit("chat_message", { roomId, message: inputMsg });
        setInputMsg("");
    };

    const toggleMic = () => {
        const enabled = myStreamRef.current.getAudioTracks()[0].enabled;
        myStreamRef.current.getAudioTracks()[0].enabled = !enabled;
        setMicOn(!enabled);
    };

    const toggleCam = () => {
        const enabled = myStreamRef.current.getVideoTracks()[0].enabled;
        myStreamRef.current.getVideoTracks()[0].enabled = !enabled;
        setCamOn(!enabled);
    };

    // ============================================================
    //  ë Œë”ë§ (ê¸°ì¡´ ìŠ¤íƒ€ì¼ ìœ ì§€)
    // ============================================================
    return (
        <div style={styles.container}>
            {/* --- ë¹„ë””ì˜¤ ì˜ì—­ --- */}
            <div style={{...styles.videoArea, width: isChatOpen ? 'calc(100% - 320px)' : '100%'}}>
                <div style={styles.grid}>
                    {/* ë‚´ í™”ë©´ */}
                    <div style={styles.videoCard}>
                        <video ref={myVideoRef} autoPlay playsInline style={{...styles.video, transform: 'scaleX(-1)'}} />
                        <span style={styles.nameTag}>{myName} (ë‚˜)</span>
                        {!micOn && <span style={styles.muteIcon}>ğŸ”‡</span>}
                    </div>

                    {/* ìƒëŒ€ë°© í™”ë©´ë“¤ */}
                    {peers.map(p => (
                        <div key={p.socketId} style={styles.videoCard}>
                            <RemoteVideo stream={p.stream} />
                            <span style={styles.nameTag}>{p.name}</span>
                        </div>
                    ))}
                </div>

                {/* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ë°” */}
                <div style={styles.controls}>
                    <button onClick={toggleMic} style={{...styles.btn, background: micOn ? '#3c4043' : '#ea4335'}}>
                        {micOn ? <BsMic/> : <BsMicMute/>}
                    </button>
                    <button onClick={toggleCam} style={{...styles.btn, background: camOn ? '#3c4043' : '#ea4335'}}>
                        {camOn ? <BsCameraVideo/> : <BsCameraVideoOff/>}
                    </button>
                    <button onClick={() => setIsChatOpen(!isChatOpen)} style={{...styles.btn, background: isChatOpen ? '#8ab4f8' : '#3c4043', color: isChatOpen ? '#000' : '#fff'}}>
                        <BsChatDots/>
                    </button>
                    <button onClick={handleEndCall} style={{...styles.btn, background: '#ea4335', width: 60}}>
                        <BsTelephoneX/>
                    </button>
                </div>
            </div>

            {/* --- ì±„íŒ… ì‚¬ì´ë“œë°” --- */}
            {isChatOpen && (
                <div style={styles.chatSidebar}>
                    <div style={styles.chatHeader}>
                        <h3>ì±„íŒ…</h3>
                        <IoClose onClick={() => setIsChatOpen(false)} style={{cursor:'pointer'}} size={24}/>
                    </div>
                    <div style={styles.chatBody}>
                        {msgs.map((m, i) => (
                            <div key={i} style={styles.chatMsg}>
                                <b>{m.sender}</b>
                                <div>{m.message}</div>
                                <small style={{color:'#888', fontSize:'0.7em'}}>
                                    {new Date(m.timestamp).toLocaleTimeString()}
                                </small>
                            </div>
                        ))}
                    </div>
                    <div style={styles.chatInputBox}>
                        <input 
                            style={styles.input}
                            value={inputMsg}
                            onChange={(e) => setInputMsg(e.target.value)}
                            onKeyPress={(e) => e.key === 'Enter' && sendChat()}
                            placeholder="ë©”ì‹œì§€ ì…ë ¥..."
                        />
                        <button onClick={sendChat} style={styles.sendBtn}><BsSend/></button>
                    </div>
                </div>
            )}
        </div>
    );
};

// ê°œë³„ ë¹„ë””ì˜¤ ì»´í¬ë„ŒíŠ¸
const RemoteVideo = ({ stream }) => {
    const ref = useRef();
    useEffect(() => { 
        if (ref.current && stream) { 
            console.log("âœ… ì›ê²© ìŠ¤íŠ¸ë¦¼ ë¹„ë””ì˜¤ íƒœê·¸ í• ë‹¹ ì™„ë£Œ");
            ref.current.srcObject = stream; 
        } 
    }, [stream]);

    return <video ref={ref} autoPlay playsInline style={styles.video} />;
};

// ìŠ¤íƒ€ì¼ ì •ì˜
const styles = {
    container: { display: 'flex', width: '100vw', height: '100vh', background: '#202124', color: 'white', overflow: 'hidden' },
    videoArea: { position: 'relative', display: 'flex', justifyContent: 'center', alignItems: 'center', transition: '0.3s' },
    grid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '20px', width: '95%', height: '85%' },
    videoCard: { position: 'relative', background: '#3c4043', borderRadius: '10px', overflow: 'hidden', boxShadow: '0 4px 6px rgba(0,0,0,0.3)' },
    video: { width: '100%', height: '100%', objectFit: 'cover' },
    nameTag: { position: 'absolute', bottom: 10, left: 10, background: 'rgba(0,0,0,0.6)', padding: '4px 8px', borderRadius: 4, fontSize: 14 },
    muteIcon: { position: 'absolute', top: 10, right: 10, background: 'rgba(0,0,0,0.6)', padding: 5, borderRadius: '50%' },
    controls: { position: 'absolute', bottom: 30, display: 'flex', gap: 15, background: 'rgba(0,0,0,0.5)', padding: '10px 20px', borderRadius: 50 },
    btn: { width: 50, height: 50, borderRadius: '50%', border: 'none', color: '#fff', fontSize: 20, cursor: 'pointer', display: 'flex', justifyContent: 'center', alignItems: 'center' },
    chatSidebar: { width: 320, background: 'white', color: 'black', display: 'flex', flexDirection: 'column', borderLeft: '1px solid #ddd' },
    chatHeader: { padding: 20, borderBottom: '1px solid #eee', display: 'flex', justifyContent: 'space-between', alignItems: 'center' },
    chatBody: { flex: 1, padding: 15, overflowY: 'auto', background: '#f8f9fa' },
    chatMsg: { marginBottom: 10, padding: 10, background: 'white', borderRadius: 8, boxShadow: '0 1px 2px rgba(0,0,0,0.1)' },
    chatInputBox: { padding: 15, borderTop: '1px solid #eee', display: 'flex', gap: 10 },
    input: { flex: 1, padding: 10, borderRadius: 20, border: '1px solid #ddd', outline: 'none' },
    sendBtn: { width: 40, height: 40, borderRadius: '50%', border: 'none', background: '#4c84af', color: 'white', cursor: 'pointer' }
};

export default VideoMeetingRoom;